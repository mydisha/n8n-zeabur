# Zeabur Web Interface Deployment Guide

## üåê Complete Setup for Zeabur Web Dashboard

### Step 1: Repository Structure
Create this structure in your GitHub repository:

```
whatsapp-expense-bot/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docker-compose.yml (for local testing)
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îî‚îÄ‚îÄ init.sql
‚îú‚îÄ‚îÄ n8n-workflows/
‚îÇ   ‚îú‚îÄ‚îÄ expense-tracker.json
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ README.md
```

## üê≥ Dockerfile for Zeabur Web Deployment

```dockerfile
# Use official golang image
FROM golang:1.21-alpine AS builder

# Install git and build dependencies
RUN apk add --no-cache git gcc musl-dev

WORKDIR /app

# Copy go.mod and go.sum first for better caching
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN CGO_ENABLED=1 GOOS=linux go build -o whatsapp-web .

# Final stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates tzdata curl

WORKDIR /root/

# Copy the binary from builder stage
COPY --from=builder /app/whatsapp-web .
COPY --from=builder /app/views ./views
COPY --from=builder /app/docs ./docs

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Run the application
CMD ["./whatsapp-web"]
```

## üìä Getting PostgreSQL Credentials in Zeabur Web

### Method 1: From Zeabur Dashboard
1. Go to your Zeabur project dashboard
2. Click on your PostgreSQL service
3. Go to "Variables" or "Environment" tab
4. You'll see:
   ```
   POSTGRES_HOST=your-postgres-host.zeabur.app
   POSTGRES_PORT=5432
   POSTGRES_USER=root (default)
   POSTGRES_PASSWORD=<auto-generated>
   POSTGRES_DATABASE=zeabur (default)
   ```

### Method 2: Connection String Format
Zeabur provides connection string in this format:
```
postgresql://username:password@host:port/database
```

Example:
```
postgresql://root:abc123xyz@postgresql-service-abc.zeabur.app:5432/zeabur
```

## üöÄ Zeabur Web Deployment Steps

### Step 1: Create Services in Zeabur Dashboard

#### 1.1 Create PostgreSQL Service
1. Login to [Zeabur Dashboard](https://dash.zeabur.com)
2. Create new project: "whatsapp-expense-bot"
3. Click "Add Service" ‚Üí "Database" ‚Üí "PostgreSQL"
4. Service name: `postgres-db`
5. Click "Deploy"
6. **Save the credentials shown!**

#### 1.2 Create Redis Service
1. Click "Add Service" ‚Üí "Database" ‚Üí "Redis" 
2. Service name: `redis-cache`
3. Click "Deploy"
4. **Save the connection details!**

#### 1.3 Create n8n Service
1. Click "Add Service" ‚Üí "Template" ‚Üí "n8n"
2. Service name: `n8n-workflow`
3. Environment variables:
   ```
   DB_TYPE=postgresdb
   DB_POSTGRESDB_HOST=postgres-db
   DB_POSTGRESDB_PORT=5432
   DB_POSTGRESDB_DATABASE=zeabur
   DB_POSTGRESDB_USER=root
   DB_POSTGRESDB_PASSWORD=<your-postgres-password>
   ```
4. Click "Deploy"

#### 1.4 Create WhatsApp Bot Service
1. Click "Add Service" ‚Üí "Git Repository"
2. Connect your GitHub repository
3. Service name: `whatsapp-bot`
4. Build settings:
   - Build Command: `go mod download && go build -o whatsapp-web .`
   - Start Command: `./whatsapp-web`
   - Port: `8080`

### Step 2: Environment Variables for WhatsApp Bot

In Zeabur dashboard, set these environment variables for your WhatsApp bot service:

```bash
# Database Configuration
DATABASE_URL=postgresql://root:<postgres-password>@postgres-db:5432/zeabur

# Redis Configuration  
REDIS_URL=redis://redis-cache:6379

# Application Settings
PORT=8080
WEBHOOK_URL=https://<your-n8n-domain>.zeabur.app/webhook/whatsapp
WEBHOOK_SECRET=your-secret-key-here
SESSION_TIMEOUT=3600
MAX_RETRIES=3

# Optional: LLM API Keys
DEEPSEEK_API_KEY=your-deepseek-key
GEMINI_API_KEY=your-gemini-key
OPENAI_API_KEY=your-openai-key

# Google Sheets (if using)
GOOGLE_SHEETS_SPREADSHEET_ID=your-spreadsheet-id
GOOGLE_SHEETS_CREDENTIALS=your-base64-encoded-json
```

## üì± WhatsApp Bot Code (main.go)

```go
package main

import (
    "database/sql"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "strconv"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/go-redis/redis/v8"
    _ "github.com/lib/pq"
)

type ExpenseMessage struct {
    ID          string    `json:"id"`
    Message     string    `json:"message"`
    From        string    `json:"from"`
    PushName    string    `json:"pushName"`
    GroupID     string    `json:"groupId"`
    GroupName   string    `json:"groupName"`
    Timestamp   int64     `json:"timestamp"`
    Type        string    `json:"type"`
}

type WebhookPayload struct {
    MessageID   string    `json:"messageId"`
    Message     string    `json:"message"`
    Sender      string    `json:"sender"`
    SenderName  string    `json:"senderName"`
    GroupID     string    `json:"groupId"`
    GroupName   string    `json:"groupName"`
    Timestamp   time.Time `json:"timestamp"`
    MessageType string    `json:"messageType"`
    IsGroup     bool      `json:"isGroup"`
}

var (
    db          *sql.DB
    redisClient *redis.Client
)

func main() {
    // Initialize database
    initDB()
    
    // Initialize Redis
    initRedis()
    
    // Initialize Gin router
    r := gin.Default()
    
    // Health check endpoint
    r.GET("/health", healthCheck)
    
    // WhatsApp webhook endpoint
    r.POST("/webhook", webhookHandler)
    
    // Get QR code endpoint
    r.GET("/qr", getQRCode)
    
    // Start server
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    log.Printf("Server starting on port %s", port)
    r.Run(":" + port)
}

func initDB() {
    databaseURL := os.Getenv("DATABASE_URL")
    if databaseURL == "" {
        log.Fatal("DATABASE_URL environment variable is required")
    }
    
    var err error
    db, err = sql.Open("postgres", databaseURL)
    if err != nil {
        log.Fatal("Failed to connect to database:", err)
    }
    
    // Test connection
    if err = db.Ping(); err != nil {
        log.Fatal("Database ping failed:", err)
    }
    
    // Create tables
    createTables()
    
    log.Println("Database connected successfully")
}

func initRedis() {
    redisURL := os.Getenv("REDIS_URL")
    if redisURL == "" {
        redisURL = "redis://localhost:6379"
    }
    
    opt, err := redis.ParseURL(redisURL)
    if err != nil {
        log.Fatal("Failed to parse Redis URL:", err)
    }
    
    redisClient = redis.NewClient(opt)
    
    // Test connection
    ctx := context.Background()
    _, err = redisClient.Ping(ctx).Result()
    if err != nil {
        log.Fatal("Redis connection failed:", err)
    }
    
    log.Println("Redis connected successfully")
}

func createTables() {
    query := `
    CREATE TABLE IF NOT EXISTS expenses (
        id SERIAL PRIMARY KEY,
        message_id VARCHAR(255) UNIQUE NOT NULL,
        group_id VARCHAR(255) NOT NULL,
        group_name VARCHAR(255),
        sender_id VARCHAR(255) NOT NULL,
        sender_name VARCHAR(255),
        item_description TEXT NOT NULL,
        amount DECIMAL(12,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'IDR',
        category VARCHAR(50),
        confidence DECIMAL(3,2),
        raw_message TEXT,
        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        synced_to_sheets BOOLEAN DEFAULT FALSE
    );
    
    CREATE INDEX IF NOT EXISTS idx_expenses_group_date ON expenses(group_id, processed_at);
    CREATE INDEX IF NOT EXISTS idx_expenses_sync_status ON expenses(synced_to_sheets);
    `
    
    _, err := db.Exec(query)
    if err != nil {
        log.Fatal("Failed to create tables:", err)
    }
}

func healthCheck(c *gin.Context) {
    c.JSON(200, gin.H{
        "status":    "healthy",
        "timestamp": time.Now().UTC(),
        "services": gin.H{
            "database": "connected",
            "redis":    "connected",
        },
    })
}

func webhookHandler(c *gin.Context) {
    var msg ExpenseMessage
    if err := c.ShouldBindJSON(&msg); err != nil {
        c.JSON(400, gin.H{"error": "Invalid JSON"})
        return
    }
    
    // Convert to webhook payload
    payload := WebhookPayload{
        MessageID:   msg.ID,
        Message:     msg.Message,
        Sender:      msg.From,
        SenderName:  msg.PushName,
        GroupID:     msg.GroupID,
        GroupName:   msg.GroupName,
        Timestamp:   time.Unix(msg.Timestamp, 0),
        MessageType: msg.Type,
        IsGroup:     msg.GroupID != "",
    }
    
    // Send to n8n webhook
    go sendToN8N(payload)
    
    c.JSON(200, gin.H{"status": "received"})
}

func sendToN8N(payload WebhookPayload) {
    webhookURL := os.Getenv("WEBHOOK_URL")
    if webhookURL == "" {
        log.Println("WEBHOOK_URL not configured")
        return
    }
    
    jsonData, err := json.Marshal(payload)
    if err != nil {
        log.Printf("Failed to marshal payload: %v", err)
        return
    }
    
    resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        log.Printf("Failed to send webhook: %v", err)
        return
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != 200 {
        log.Printf("Webhook returned status: %d", resp.StatusCode)
    }
}

func getQRCode(c *gin.Context) {
    // This would integrate with go-whatsapp-web-multidevice
    // For now, return placeholder
    c.JSON(200, gin.H{
        "message": "Please scan QR code to connect WhatsApp",
        "qr_endpoint": "/app/qr",
    })
}
```

## üìÑ Required Files

### go.mod
```go
module whatsapp-expense-bot

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/go-redis/redis/v8 v8.11.5
    github.com/lib/pq v1.10.9
)
```

### .env.example
```bash
# Database (Get from Zeabur PostgreSQL service)
DATABASE_URL=postgresql://root:password@postgres-db:5432/zeabur

# Redis (Get from Zeabur Redis service)
REDIS_URL=redis://redis-cache:6379

# Application
PORT=8080
WEBHOOK_URL=https://your-n8n-service.zeabur.app/webhook/whatsapp
WEBHOOK_SECRET=your-secret-key

# Optional: LLM APIs
DEEPSEEK_API_KEY=your-key
GEMINI_API_KEY=your-key
```

## üîÑ n8n Workflow Import

1. Access your n8n service URL: `https://your-n8n-service.zeabur.app`
2. Create account/login
3. Go to "Workflows" ‚Üí "Import from File"
4. Upload the workflow JSON file
5. Configure Google Sheets credentials
6. Activate the workflow

## üìã Deployment Checklist

- [ ] Create PostgreSQL service in Zeabur
- [ ] Create Redis service in Zeabur  
- [ ] Create n8n service in Zeabur
- [ ] Note down all credentials
- [ ] Push code to GitHub repository
- [ ] Create WhatsApp bot service from GitHub
- [ ] Set all environment variables
- [ ] Import n8n workflows
- [ ] Test WhatsApp connection
- [ ] Configure Google Sheets integration
- [ ] Test expense message parsing

## üîç Getting Service URLs and Credentials

### PostgreSQL Credentials Location:
1. Zeabur Dashboard ‚Üí Your Project ‚Üí PostgreSQL Service
2. Click "Connect" tab
3. Copy the connection string or individual credentials

### Service URLs:
- WhatsApp Bot: `https://whatsapp-bot-xxx.zeabur.app`
- n8n: `https://n8n-workflow-xxx.zeabur.app`
- PostgreSQL: `postgresql-service-xxx.zeabur.app:5432`

### Environment Variables Setup:
1. Go to your WhatsApp bot service
2. Click "Variables" tab
3. Add each environment variable one by one
4. Click "Redeploy" after adding variables

This setup is specifically designed for Zeabur's web interface and will work seamlessly with their service discovery and internal networking!